<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Fri Jun 22 08:09:23 UTC 2018 -->
<title>Flowables (rxjava2-extensions 0.19.3 API)</title>
<meta name="date" content="2018-06-22">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Flowables (rxjava2-extensions 0.19.3 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html" title="interface in hu.akarnokd.rxjava2.operators"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../hu/akarnokd/rxjava2/operators/FlowableTransformers.html" title="class in hu.akarnokd.rxjava2.operators"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?hu/akarnokd/rxjava2/operators/Flowables.html" target="_top">Frames</a></li>
<li><a href="Flowables.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">hu.akarnokd.rxjava2.operators</div>
<h2 title="Class Flowables" class="title">Class Flowables</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>hu.akarnokd.rxjava2.operators.Flowables</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="typeNameLabel">Flowables</span>
extends java.lang.Object</pre>
<div class="block">Utility class to create Flowable sources.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static &lt;T,S&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#generateAsync-java.util.concurrent.Callable-io.reactivex.functions.BiFunction-io.reactivex.functions.Consumer-">generateAsync</a></span>(java.util.concurrent.Callable&lt;S&gt;&nbsp;initialState,
             io.reactivex.functions.BiFunction&lt;S,<a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html" title="interface in hu.akarnokd.rxjava2.operators">FlowableAsyncEmitter</a>&lt;T&gt;,S&gt;&nbsp;asyncGenerator,
             io.reactivex.functions.Consumer&lt;? super S&gt;&nbsp;stateCleanup)</code>
<div class="block">Generates items by invoking a callback, for each downstream request one by one, that sets up an
 asynchronous call to some API that eventually responds with an item, an error or termination, while
 making sure there is only one such outstanding API call in progress and honoring the
 backpressure of the downstream.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static io.reactivex.Flowable&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#intervalBackpressure-long-long-java.util.concurrent.TimeUnit-">intervalBackpressure</a></span>(long&nbsp;initialDelay,
                    long&nbsp;period,
                    java.util.concurrent.TimeUnit&nbsp;unit)</code>
<div class="block">Periodically tries to emit an ever increasing long value or
 buffers (efficiently) such emissions until the downstream requests.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static io.reactivex.Flowable&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#intervalBackpressure-long-long-java.util.concurrent.TimeUnit-io.reactivex.Scheduler-">intervalBackpressure</a></span>(long&nbsp;initialDelay,
                    long&nbsp;period,
                    java.util.concurrent.TimeUnit&nbsp;unit,
                    io.reactivex.Scheduler&nbsp;scheduler)</code>
<div class="block">Periodically tries to emit an ever increasing long value or
 buffers (efficiently) such emissions until the downstream requests.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static io.reactivex.Flowable&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#intervalBackpressure-long-java.util.concurrent.TimeUnit-">intervalBackpressure</a></span>(long&nbsp;period,
                    java.util.concurrent.TimeUnit&nbsp;unit)</code>
<div class="block">Periodically tries to emit an ever increasing long value or
 buffers (efficiently) such emissions until the downstream requests.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static io.reactivex.Flowable&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#intervalBackpressure-long-java.util.concurrent.TimeUnit-io.reactivex.Scheduler-">intervalBackpressure</a></span>(long&nbsp;period,
                    java.util.concurrent.TimeUnit&nbsp;unit,
                    io.reactivex.Scheduler&nbsp;scheduler)</code>
<div class="block">Periodically tries to emit an ever increasing long value or
 buffers (efficiently) such emissions until the downstream requests.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static &lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;<br>io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-boolean-int-org.reactivestreams.Publisher...-">orderedMerge</a></span>(boolean&nbsp;delayErrors,
            int&nbsp;prefetch,
            org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order), allows delaying any error they may signal and sets the prefetch
 amount when requesting from these Publishers.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static &lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;<br>io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-boolean-org.reactivestreams.Publisher...-">orderedMerge</a></span>(boolean&nbsp;delayErrors,
            org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order) and allows delaying any error they may signal.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-java.util.Comparator-boolean-int-org.reactivestreams.Publisher...-">orderedMerge</a></span>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
            boolean&nbsp;delayErrors,
            int&nbsp;prefetch,
            org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator), allows delaying any error they may signal and sets the prefetch
 amount when requesting from these Publishers.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-java.util.Comparator-boolean-org.reactivestreams.Publisher...-">orderedMerge</a></span>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
            boolean&nbsp;delayErrors,
            org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator) and allows delaying any error they may signal.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-java.util.Comparator-org.reactivestreams.Publisher...-">orderedMerge</a></span>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
            org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator).</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static &lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;<br>io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-java.lang.Iterable-">orderedMerge</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order).</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static &lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;<br>io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-java.lang.Iterable-boolean-">orderedMerge</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
            boolean&nbsp;delayErrors)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order) and allows delaying any error they may signal.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static &lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;<br>io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-java.lang.Iterable-boolean-int-">orderedMerge</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
            boolean&nbsp;delayErrors,
            int&nbsp;prefetch)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order), allows delaying any error they may signal and sets the prefetch
 amount when requesting from these Publishers.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-java.lang.Iterable-java.util.Comparator-">orderedMerge</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
            java.util.Comparator&lt;? super T&gt;&nbsp;comparator)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator).</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-java.lang.Iterable-java.util.Comparator-boolean-">orderedMerge</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
            java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
            boolean&nbsp;delayErrors)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator) and allows delaying any error they may signal.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-java.lang.Iterable-java.util.Comparator-boolean-int-">orderedMerge</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
            java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
            boolean&nbsp;delayErrors,
            int&nbsp;prefetch)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator), allows delaying any error they may signal and sets the prefetch
 amount when requesting from these Publishers.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static &lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;<br>io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#orderedMerge-org.reactivestreams.Publisher...-">orderedMerge</a></span>(org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</code>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order).</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#repeat-T-">repeat</a></span>(T&nbsp;item)</code>
<div class="block">Repeats a scalar value indefinitely.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#repeatCallable-java.util.concurrent.Callable-">repeatCallable</a></span>(java.util.concurrent.Callable&lt;T&gt;&nbsp;callable)</code>
<div class="block">Repeatedly calls the given Callable to produce items indefinitely.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static &lt;T,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-io.reactivex.functions.Function-org.reactivestreams.Publisher...-">zipLatest</a></span>(io.reactivex.functions.Function&lt;? super java.lang.Object[],? extends R&gt;&nbsp;combiner,
         org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static &lt;T,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-io.reactivex.functions.Function-io.reactivex.Scheduler-org.reactivestreams.Publisher...-">zipLatest</a></span>(io.reactivex.functions.Function&lt;? super java.lang.Object[],? extends R&gt;&nbsp;combiner,
         io.reactivex.Scheduler&nbsp;scheduler,
         org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static &lt;T,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-java.lang.Iterable-io.reactivex.functions.Function-">zipLatest</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
         io.reactivex.functions.Function&lt;? super java.lang.Object[],? extends R&gt;&nbsp;combiner)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static &lt;T,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-java.lang.Iterable-io.reactivex.functions.Function-io.reactivex.Scheduler-">zipLatest</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
         io.reactivex.functions.Function&lt;? super java.lang.Object[],? extends R&gt;&nbsp;combiner,
         io.reactivex.Scheduler&nbsp;scheduler)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static &lt;T1,T2,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-">zipLatest</a></span>(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
         org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
         io.reactivex.functions.BiFunction&lt;? super T1,? super T2,? extends R&gt;&nbsp;combiner)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-io.reactivex.Scheduler-">zipLatest</a></span>(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
         org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
         io.reactivex.functions.BiFunction&lt;? super T1,? super T2,? extends R&gt;&nbsp;combiner,
         io.reactivex.Scheduler&nbsp;scheduler)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,R&gt;<br>io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.Function3-">zipLatest</a></span>(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
         org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
         org.reactivestreams.Publisher&lt;T3&gt;&nbsp;source3,
         io.reactivex.functions.Function3&lt;? super T1,? super T2,? super T3,? extends R&gt;&nbsp;combiner)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,R&gt;<br>io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.Function3-io.reactivex.Scheduler-">zipLatest</a></span>(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
         org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
         org.reactivestreams.Publisher&lt;T3&gt;&nbsp;source3,
         io.reactivex.functions.Function3&lt;? super T1,? super T2,? super T3,? extends R&gt;&nbsp;combiner,
         io.reactivex.Scheduler&nbsp;scheduler)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4,R&gt;<br>io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.Function4-">zipLatest</a></span>(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
         org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
         org.reactivestreams.Publisher&lt;T3&gt;&nbsp;source3,
         org.reactivestreams.Publisher&lt;T4&gt;&nbsp;source4,
         io.reactivex.functions.Function4&lt;? super T1,? super T2,? super T3,? super T4,? extends R&gt;&nbsp;combiner)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4,R&gt;<br>io.reactivex.Flowable&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../hu/akarnokd/rxjava2/operators/Flowables.html#zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.Function4-io.reactivex.Scheduler-">zipLatest</a></span>(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
         org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
         org.reactivestreams.Publisher&lt;T3&gt;&nbsp;source3,
         org.reactivestreams.Publisher&lt;T4&gt;&nbsp;source4,
         io.reactivex.functions.Function4&lt;? super T1,? super T2,? super T3,? super T4,? extends R&gt;&nbsp;combiner,
         io.reactivex.Scheduler&nbsp;scheduler)</code>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="orderedMerge-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-boolean-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(boolean&nbsp;delayErrors,
                                                                                                                                                                  org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order) and allows delaying any error they may signal.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>delayErrors</code> - if true, source errors are delayed until all sources terminate in some way</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-boolean-int-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(boolean&nbsp;delayErrors,
                                                                                                                                                                  int&nbsp;prefetch,
                                                                                                                                                                  org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order), allows delaying any error they may signal and sets the prefetch
 amount when requesting from these Publishers.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>delayErrors</code> - if true, source errors are delayed until all sources terminate in some way</dd>
<dd><code>prefetch</code> - the number of items to prefetch from the sources</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-java.util.Comparator-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                                                                                          org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>comparator</code> - the comparator to use for comparing items;
                   it is called with the last known smallest in its first argument</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-java.util.Comparator-boolean-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                                                                                          boolean&nbsp;delayErrors,
                                                                                                                          org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator) and allows delaying any error they may signal.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>comparator</code> - the comparator to use for comparing items;
                   it is called with the last known smallest in its first argument</dd>
<dd><code>delayErrors</code> - if true, source errors are delayed until all sources terminate in some way</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-java.util.Comparator-boolean-int-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                                                                                          boolean&nbsp;delayErrors,
                                                                                                                          int&nbsp;prefetch,
                                                                                                                          org.reactivestreams.Publisher&lt;T&gt;...&nbsp;sources)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator), allows delaying any error they may signal and sets the prefetch
 amount when requesting from these Publishers.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>comparator</code> - the comparator to use for comparing items;
                   it is called with the last known smallest in its first argument</dd>
<dd><code>delayErrors</code> - if true, source errors are delayed until all sources terminate in some way</dd>
<dd><code>prefetch</code> - the number of items to prefetch from the sources</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-java.lang.Iterable-java.util.Comparator-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
                                                                                                                          java.util.Comparator&lt;? super T&gt;&nbsp;comparator)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>comparator</code> - the comparator to use for comparing items;
                   it is called with the last known smallest in its first argument</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-java.lang.Iterable-java.util.Comparator-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
                                                                                                                          java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                                                                                          boolean&nbsp;delayErrors)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator) and allows delaying any error they may signal.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>comparator</code> - the comparator to use for comparing items;
                   it is called with the last known smallest in its first argument</dd>
<dd><code>delayErrors</code> - if true, source errors are delayed until all sources terminate in some way</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-java.lang.Iterable-java.util.Comparator-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
                                                                                                                          java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                                                                                          boolean&nbsp;delayErrors,
                                                                                                                          int&nbsp;prefetch)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by the Comparator), allows delaying any error they may signal and sets the prefetch
 amount when requesting from these Publishers.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>comparator</code> - the comparator to use for comparing items;
                   it is called with the last known smallest in its first argument</dd>
<dd><code>delayErrors</code> - if true, source errors are delayed until all sources terminate in some way</dd>
<dd><code>prefetch</code> - the number of items to prefetch from the sources</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-java.lang.Iterable-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
                                                                                                                                                                  boolean&nbsp;delayErrors)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order) and allows delaying any error they may signal.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>delayErrors</code> - if true, source errors are delayed until all sources terminate in some way</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="orderedMerge-java.lang.Iterable-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedMerge</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T extends java.lang.Comparable&lt;? super T&gt;&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;orderedMerge(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;sources,
                                                                                                                                                                  boolean&nbsp;delayErrors,
                                                                                                                                                                  int&nbsp;prefetch)</pre>
<div class="block">Merges the source Publishers in an ordered fashion picking the smallest of the available value from
 them (determined by their natural order), allows delaying any error they may signal and sets the prefetch
 amount when requesting from these Publishers.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type of all sources</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - the iterable sequence of sources</dd>
<dd><code>delayErrors</code> - if true, source errors are delayed until all sources terminate in some way</dd>
<dd><code>prefetch</code> - the number of items to prefetch from the sources</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.8.0</dd>
</dl>
</li>
</ul>
<a name="repeat-java.lang.Object-">
<!--   -->
</a><a name="repeat-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;repeat(T&nbsp;item)</pre>
<div class="block">Repeats a scalar value indefinitely.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>item</code> - the value to repeat</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.14.2</dd>
</dl>
</li>
</ul>
<a name="repeatCallable-java.util.concurrent.Callable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeatCallable</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;repeatCallable(java.util.concurrent.Callable&lt;T&gt;&nbsp;callable)</pre>
<div class="block">Repeatedly calls the given Callable to produce items indefinitely.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the value type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callable</code> - the Callable to call</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.14.2</dd>
</dl>
</li>
</ul>
<a name="intervalBackpressure-long-java.util.concurrent.TimeUnit-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intervalBackpressure</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="io.reactivex:computation")
public static&nbsp;io.reactivex.Flowable&lt;java.lang.Long&gt;&nbsp;intervalBackpressure(long&nbsp;period,
                                                                                                                                                               java.util.concurrent.TimeUnit&nbsp;unit)</pre>
<div class="block">Periodically tries to emit an ever increasing long value or
 buffers (efficiently) such emissions until the downstream requests.
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and
  no emission is lost, however, the timing of the reception of the
  values is now dependent on the downstream backpressure.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator uses the <code>computation</code> <code>Scheduler</code> to time
  the emission and likely deliver the value (unless backpressured).</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>period</code> - the emission period (including the delay for the first emission)</dd>
<dd><code>unit</code> - the emission time unit</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.15.0</dd>
</dl>
</li>
</ul>
<a name="intervalBackpressure-long-java.util.concurrent.TimeUnit-io.reactivex.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intervalBackpressure</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="custom")
public static&nbsp;io.reactivex.Flowable&lt;java.lang.Long&gt;&nbsp;intervalBackpressure(long&nbsp;period,
                                                                                                                                             java.util.concurrent.TimeUnit&nbsp;unit,
                                                                                                                                             io.reactivex.Scheduler&nbsp;scheduler)</pre>
<div class="block">Periodically tries to emit an ever increasing long value or
 buffers (efficiently) such emissions until the downstream requests.
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and
  no emission is lost, however, the timing of the reception of the
  values is now dependent on the downstream backpressure.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator uses the <code>computation</code> <code>Scheduler</code> to time
  the emission and likely deliver the value (unless backpressured).</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>period</code> - the emission period (including the delay for the first emission)</dd>
<dd><code>unit</code> - the emission time unit</dd>
<dd><code>scheduler</code> - the scheduler to use for timing and likely emitting items</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.15.0</dd>
</dl>
</li>
</ul>
<a name="intervalBackpressure-long-long-java.util.concurrent.TimeUnit-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intervalBackpressure</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="io.reactivex:computation")
public static&nbsp;io.reactivex.Flowable&lt;java.lang.Long&gt;&nbsp;intervalBackpressure(long&nbsp;initialDelay,
                                                                                                                                                               long&nbsp;period,
                                                                                                                                                               java.util.concurrent.TimeUnit&nbsp;unit)</pre>
<div class="block">Periodically tries to emit an ever increasing long value or
 buffers (efficiently) such emissions until the downstream requests.
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and
  no emission is lost, however, the timing of the reception of the
  values is now dependent on the downstream backpressure.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator uses the <code>computation</code> <code>Scheduler</code> to time
  the emission and likely deliver the value (unless backpressured).</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initialDelay</code> - the initial delay before emitting the first 0L</dd>
<dd><code>period</code> - the emission period after the first emission</dd>
<dd><code>unit</code> - the emission time unit</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.15.0</dd>
</dl>
</li>
</ul>
<a name="intervalBackpressure-long-long-java.util.concurrent.TimeUnit-io.reactivex.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intervalBackpressure</h4>
<pre>@BackpressureSupport(value=FULL)
 @SchedulerSupport(value="custom")
public static&nbsp;io.reactivex.Flowable&lt;java.lang.Long&gt;&nbsp;intervalBackpressure(long&nbsp;initialDelay,
                                                                                                                                             long&nbsp;period,
                                                                                                                                             java.util.concurrent.TimeUnit&nbsp;unit,
                                                                                                                                             io.reactivex.Scheduler&nbsp;scheduler)</pre>
<div class="block">Periodically tries to emit an ever increasing long value or
 buffers (efficiently) such emissions until the downstream requests.
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and
  no emission is lost, however, the timing of the reception of the
  values is now dependent on the downstream backpressure.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator uses the <code>Scheduler</code> provided to time
  the emission and likely deliver the value (unless backpressured).</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initialDelay</code> - the initial delay before emitting the first 0L</dd>
<dd><code>period</code> - the emission period (including the delay for the first emission)</dd>
<dd><code>unit</code> - the emission time unit</dd>
<dd><code>scheduler</code> - the scheduler to use for timing and likely emitting items</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.15.0</dd>
</dl>
</li>
</ul>
<a name="zipLatest-io.reactivex.functions.Function-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(io.reactivex.functions.Function&lt;? super java.lang.Object[],? extends R&gt;&nbsp;combiner,
                                                                                                                                 org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator doesn't run on any particular <code>Scheduler</code>
  and the combined item emission happens on the thread that won the internal emission-right race.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the common source value type</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>sources</code> - the array of source Publishers to zip/combine</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="zipLatest-io.reactivex.functions.Function-io.reactivex.Scheduler-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="custom")
public static&nbsp;&lt;T,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(io.reactivex.functions.Function&lt;? super java.lang.Object[],? extends R&gt;&nbsp;combiner,
                                                                                                                                   io.reactivex.Scheduler&nbsp;scheduler,
                                                                                                                                   org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator emits the combined items on the <code>Scheduler</code> provided.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the common source value type</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>sources</code> - the array of source Publishers to zip/combine</dd>
<dd><code>scheduler</code> - the Scheduler to use for emitting items and/or terminal signals</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="zipLatest-java.lang.Iterable-io.reactivex.functions.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                                                                                                                                 io.reactivex.functions.Function&lt;? super java.lang.Object[],? extends R&gt;&nbsp;combiner)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator doesn't run on any particular <code>Scheduler</code> scheduler
  and the combined item emission happens on the thread that won the internal emission-right race.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the common source value type</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>sources</code> - the array of source Publishers to zip/combine</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="zipLatest-java.lang.Iterable-io.reactivex.functions.Function-io.reactivex.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="custom")
public static&nbsp;&lt;T,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                                                                                                                                   io.reactivex.functions.Function&lt;? super java.lang.Object[],? extends R&gt;&nbsp;combiner,
                                                                                                                                   io.reactivex.Scheduler&nbsp;scheduler)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator emits the combined items on the <code>Scheduler</code> provided.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the common source value type</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>sources</code> - the array of source Publishers to zip/combine</dd>
<dd><code>scheduler</code> - the Scheduler to use for emitting items and/or terminal signals</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T1,T2,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
                                                                                                                                     org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
                                                                                                                                     io.reactivex.functions.BiFunction&lt;? super T1,? super T2,? extends R&gt;&nbsp;combiner)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator doesn't run on any particular <code>Scheduler</code> scheduler
  and the combined item emission happens on the thread that won the internal emission-right race.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - the value type of the first source Publisher</dd>
<dd><code>T2</code> - the value type of the second source Publisher</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>source1</code> - the first source Publisher instance</dd>
<dd><code>source2</code> - the second source Publisher instance</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-io.reactivex.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="custom")
public static&nbsp;&lt;T1,T2,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
                                                                                                                                       org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
                                                                                                                                       io.reactivex.functions.BiFunction&lt;? super T1,? super T2,? extends R&gt;&nbsp;combiner,
                                                                                                                                       io.reactivex.Scheduler&nbsp;scheduler)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator emits the combined items on the <code>Scheduler</code> provided.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - the value type of the first source Publisher</dd>
<dd><code>T2</code> - the value type of the second source Publisher</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>source1</code> - the first source Publisher instance</dd>
<dd><code>source2</code> - the second source Publisher instance</dd>
<dd><code>scheduler</code> - the Scheduler to use for emitting items and/or terminal signals</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.Function3-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T1,T2,T3,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
                                                                                                                                        org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
                                                                                                                                        org.reactivestreams.Publisher&lt;T3&gt;&nbsp;source3,
                                                                                                                                        io.reactivex.functions.Function3&lt;? super T1,? super T2,? super T3,? extends R&gt;&nbsp;combiner)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator doesn't run on any particular <code>Scheduler</code> scheduler
  and the combined item emission happens on the thread that won the internal emission-right race.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - the value type of the first source Publisher</dd>
<dd><code>T2</code> - the value type of the second source Publisher</dd>
<dd><code>T3</code> - the value type of the third source Publisher</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>source1</code> - the first source Publisher instance</dd>
<dd><code>source2</code> - the second source Publisher instance</dd>
<dd><code>source3</code> - the third source Publisher instance</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.Function3-io.reactivex.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="custom")
public static&nbsp;&lt;T1,T2,T3,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
                                                                                                                                          org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
                                                                                                                                          org.reactivestreams.Publisher&lt;T3&gt;&nbsp;source3,
                                                                                                                                          io.reactivex.functions.Function3&lt;? super T1,? super T2,? super T3,? extends R&gt;&nbsp;combiner,
                                                                                                                                          io.reactivex.Scheduler&nbsp;scheduler)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator emits the combined items on the <code>Scheduler</code> provided.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - the value type of the first source Publisher</dd>
<dd><code>T2</code> - the value type of the second source Publisher</dd>
<dd><code>T3</code> - the value type of the third source Publisher</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>source1</code> - the first source Publisher instance</dd>
<dd><code>source2</code> - the second source Publisher instance</dd>
<dd><code>source3</code> - the third source Publisher instance</dd>
<dd><code>scheduler</code> - the Scheduler to use for emitting items and/or terminal signals</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.Function4-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T1,T2,T3,T4,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
                                                                                                                                           org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
                                                                                                                                           org.reactivestreams.Publisher&lt;T3&gt;&nbsp;source3,
                                                                                                                                           org.reactivestreams.Publisher&lt;T4&gt;&nbsp;source4,
                                                                                                                                           io.reactivex.functions.Function4&lt;? super T1,? super T2,? super T3,? super T4,? extends R&gt;&nbsp;combiner)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator doesn't run on any particular <code>Scheduler</code> scheduler
  and the combined item emission happens on the thread that won the internal emission-right race.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - the value type of the first source Publisher</dd>
<dd><code>T2</code> - the value type of the second source Publisher</dd>
<dd><code>T3</code> - the value type of the third source Publisher</dd>
<dd><code>T4</code> - the value type of the fourth source Publisher</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>source1</code> - the first source Publisher instance</dd>
<dd><code>source2</code> - the second source Publisher instance</dd>
<dd><code>source3</code> - the third source Publisher instance</dd>
<dd><code>source4</code> - the fourth source Publisher instance</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="zipLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-io.reactivex.functions.Function4-io.reactivex.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipLatest</h4>
<pre>@BackpressureSupport(value=UNBOUNDED_IN)
 @SchedulerSupport(value="custom")
public static&nbsp;&lt;T1,T2,T3,T4,R&gt;&nbsp;io.reactivex.Flowable&lt;R&gt;&nbsp;zipLatest(org.reactivestreams.Publisher&lt;T1&gt;&nbsp;source1,
                                                                                                                                             org.reactivestreams.Publisher&lt;T2&gt;&nbsp;source2,
                                                                                                                                             org.reactivestreams.Publisher&lt;T3&gt;&nbsp;source3,
                                                                                                                                             org.reactivestreams.Publisher&lt;T4&gt;&nbsp;source4,
                                                                                                                                             io.reactivex.functions.Function4&lt;? super T1,? super T2,? super T3,? super T4,? extends R&gt;&nbsp;combiner,
                                                                                                                                             io.reactivex.Scheduler&nbsp;scheduler)</pre>
<div class="block">Zips the latest available values of the source Publishers via a combiner function where the
 emission rate is determined by the slowest Publisher and the downstream consumption rate.
 <p>
 Non-consumed source values are overwritten by newer values. Unlike <code>combineLatest</code>, source
 values are not reused to form new combinations.
 <p>
 If any of the sources runs out of items, the other sources are cancelled and the sequence completes.
 <pre><code>
 A: ---o-o-o------o-o----o---o-|-------
 B: ---------x-x--x-------x-----x--x---
 ======= zipLatest (o, x -&gt; M) ========
 R: ---------M----M-------M-----M|-----
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors the backpressure of the downstream and consumes
  the source Publishers in an unbounded manner, keeping only their latest values temporarily.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd>The operator emits the combined items on the <code>Scheduler</code> provided.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T1</code> - the value type of the first source Publisher</dd>
<dd><code>T2</code> - the value type of the second source Publisher</dd>
<dd><code>T3</code> - the value type of the third source Publisher</dd>
<dd><code>T4</code> - the value type of the fourth source Publisher</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>combiner</code> - the function receiving the latest values of the sources and returns a value
                 to be emitted to the downstream.</dd>
<dd><code>source1</code> - the first source Publisher instance</dd>
<dd><code>source2</code> - the second source Publisher instance</dd>
<dd><code>source3</code> - the third source Publisher instance</dd>
<dd><code>source4</code> - the fourth source Publisher instance</dd>
<dd><code>scheduler</code> - the Scheduler to use for emitting items and/or terminal signals</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance.</dd>
</dl>
</li>
</ul>
<a name="generateAsync-java.util.concurrent.Callable-io.reactivex.functions.BiFunction-io.reactivex.functions.Consumer-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>generateAsync</h4>
<pre>@CheckReturnValue
 @BackpressureSupport(value=FULL)
 @SchedulerSupport(value="none")
public static&nbsp;&lt;T,S&gt;&nbsp;io.reactivex.Flowable&lt;T&gt;&nbsp;generateAsync(java.util.concurrent.Callable&lt;S&gt;&nbsp;initialState,
                                                                                                                                                io.reactivex.functions.BiFunction&lt;S,<a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html" title="interface in hu.akarnokd.rxjava2.operators">FlowableAsyncEmitter</a>&lt;T&gt;,S&gt;&nbsp;asyncGenerator,
                                                                                                                                                io.reactivex.functions.Consumer&lt;? super S&gt;&nbsp;stateCleanup)</pre>
<div class="block">Generates items by invoking a callback, for each downstream request one by one, that sets up an
 asynchronous call to some API that eventually responds with an item, an error or termination, while
 making sure there is only one such outstanding API call in progress and honoring the
 backpressure of the downstream.
 <p>
 This operator allows the bridging of the asynchronous and backpressurable world with the reactive world,
 where backpressure is the emergent effect of making sure there is only one outstanding API call
 at a time which responds with at most one item per invocation.
 <p>
 Note that the implementation may have one outstanding API call even if the downstream hasn't requested more
 and as such, the resulting item may get cached until the downstream requests for more.
 <p>
 During the async response, the invocation protocol of the <a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html" title="interface in hu.akarnokd.rxjava2.operators"><code>FlowableAsyncEmitter</code></a> should be as follows:
 <pre><code>
     (onNext | onNothing)? (onError | onComplete)?
 </code></pre>
 In words, an <code>onNext</code> or <code>onNothing</code> (which indicates this particular API call resulted in no
 items and the next API call can proceed) may be followed by a terminal event.
 <p>
 The methods <code>Emitter.onNext(Object)</code>, <code>Emitter.onError(Throwable)</code>,
 <code>Emitter.onComplete()</code> and <a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html#onNothing--"><code>FlowableAsyncEmitter.onNothing()</code></a> should not be called
 concurrently with each other or outside the context of the generator. The rest of the
 <a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html" title="interface in hu.akarnokd.rxjava2.operators"><code>FlowableAsyncEmitter</code></a> methods are thread-safe.
 <p>
 <b>Example:</b><br>
 Let's assume there is an async API with the following interface definition:
 <pre><code>
 interface AsyncAPI&lt;T&gt; extends AutoCloseable {

     CompletableFuture&lt;Void&gt; nextValue(Consumer&lt;? super T&gt; onValue);

 }
 </code></pre>
 When the call succeeds, the <code>onValue</code> is invoked with it. If there are no more items, the
 <code>CompletableFuture</code> returned by the last <code>nextValue</code> is completed (with null).
 If there is an error, the same <code>CompletableFuture</code> is completed exceptionally. Each
 <code>nextValue</code> invocation creates a fresh <code>CompletableFuture</code> which can be cancelled
 if necesary. <code>nextValue</code> should not be invoked again until the <code>onValue</code> callback
 has been notified.<br>
 An instance of this API can be obtained on demand, thus the state of this operator consists of the
 <code>AsyncAPI</code> instance supplied for each individual <code>Subscriber</code>. The API can be transformed into
 a <code>Flowable</code> as follows:
 <pre><code>
 Flowable&lt;Integer&gt; source = Flowable.&lt;Integer, AsyncAPI&lt;Integer&gt;&gt;generateAsync(

     // create a fresh API instance for each individual Subscriber
     () -&gt; new AsyncAPIImpl&lt;Integer&gt;(),

     // this BiFunction will be called once the operator is ready to receive the next item
     // and will invoke it again only when that item is delivered via emitter.onNext()
     (state, emitter) -&gt; {

         // issue the async API call
         CompletableFuture&lt;Void&gt; f = state.nextValue(

             // handle the value received
             value -&gt; {

                 // we have the option to signal that item
                 if (value % 2 == 0) {
                     emitter.onNext(value);
                 } else if (value == 101) {
                     // or stop altogether, which will also trigger a cleanup
                     emitter.onComplete();
                 } else {
                     // or drop it and have the operator start a new call
                     emitter.onNothing();
                 }
             }
         );

         // This API call may not produce further items or fail
         f.whenComplete((done, error) -&gt; {
             // As per the CompletableFuture API, error != null is the error outcome,
             // done is always null due to the Void type
             if (error != null) {
                 emitter.onError(error);
             } else {
                 emitter.onComplete();
             }
         });

         // In case the downstream cancels, the current API call
         // should be cancelled as well
         emitter.replaceCancellable(() -&gt; f.cancel(true));

         // some sources may want to create a fresh state object
         // after each invocation of this generator
         return state;
     },

     // cleanup the state object
     state -&gt; { state.close(); }
 )
 </code></pre>
 <dl>
  <dt><b>Backpressure:</b></dt>
  <dd>The operator honors downstream backpressure.</dd>
  <dt><b>Scheduler:</b></dt>
  <dd><code>generateAsync</code> does not operate by default on a particular <code>Scheduler</code>, however,
  the signals emitted through the <a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html" title="interface in hu.akarnokd.rxjava2.operators"><code>FlowableAsyncEmitter</code></a> may happen on any thread,
  depending on the asynchronous API.</dd>
 </dl></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the generated item type</dd>
<dd><code>S</code> - the state associated with an individual subscription.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initialState</code> - the <code>Callable</code> that returns a state object for each individual
                     <code>Subscriber</code> to the returned <code>Flowable</code>.</dd>
<dd><code>asyncGenerator</code> - the <code>BiFunction</code> called with the current state value and the
                       <a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html" title="interface in hu.akarnokd.rxjava2.operators"><code>FlowableAsyncEmitter</code></a> object and should return a new state value
                       as well as prepare and issue the async API call in a way that
                       the call's outcome is (eventually) converted into <code>onNext</code>, <code>onError</code> or
                       <code>onComplete</code> calls. The operator ensures the <code>BiFunction</code> is
                       only invoked when the previous async call produced <code>onNext</code> item and
                       this item has been delivered to the downstream.</dd>
<dd><code>stateCleanup</code> - called at most once with the current state object to allow cleaning it up after
                     the flow is cancelled or terminates via <code>Emitter.onError(Throwable)</code>
                     or <code>Emitter.onComplete()</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the new Flowable instance</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>0.18.9</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Flowable.generate(Callable, BiFunction, Consumer)</code>, 
<a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html" title="interface in hu.akarnokd.rxjava2.operators"><code>FlowableAsyncEmitter</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../hu/akarnokd/rxjava2/operators/FlowableAsyncEmitter.html" title="interface in hu.akarnokd.rxjava2.operators"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../hu/akarnokd/rxjava2/operators/FlowableTransformers.html" title="class in hu.akarnokd.rxjava2.operators"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?hu/akarnokd/rxjava2/operators/Flowables.html" target="_top">Frames</a></li>
<li><a href="Flowables.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
